<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Track & Fourier</title>

  <!-- [SEO] Basic Meta Tags -->
  <meta name="description" content="A demo where you can draw a track on a canvas, apply Fourier transforms, and visualize the animation in real-time.">
  <meta name="keywords" content="Fourier, Track, Animation, Demo, Catmull-Rom, JavaScript">
  <meta name="author" content="Rick choi">

  <!-- [SEO] Open Graph (OG) Tags -->
  <meta property="og:title" content="Canvas Track & Fourier Demo">
  <meta property="og:description" content="Draw a path on the canvas, sample it, apply a Fourier transform, and watch the resulting animation of a moving green ball.">
  <!-- <meta property="og:image" content="URL to your preview image" /> -->
  <!-- <meta property="og:url" content="URL of this page" /> -->

  <!-- [SEO] Additional (optional)
       <link rel="canonical" href="https://example.com/your-page-url" />
  -->

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      font-family: sans-serif;
      box-sizing: border-box;
    }

    #mainWrapper {
      display: flex;
      flex-direction: row;
      width: 100%;
      height: 100vh; /* Use full viewport height */
    }

    /* Left pane: Canvas */
    #leftPane {
      flex: 3;
      position: relative;
      background: #ccc;
      overflow: hidden;
    }

    /* Right pane: Controls */
    #rightPane {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      box-sizing: border-box;
      overflow-y: auto;
      background: #fafafa;
    }

    /* Canvas fills the left pane. 
       The actual drawing size is synchronized in JS. */
    #myCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Red anchors (points) */
    #anchorsContainer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .anchor {
      position: absolute;
      width: 8px; height: 8px;
      border-radius: 8px;
      background: red;
      transform: translate(-4px, -4px);
      cursor: pointer;
      pointer-events: auto;
    }
    .anchor.dragging {
      background: orange;
    }

    /* Green circle for animation */
    #greenCircle {
      position: absolute;
      width: 10px; height: 10px;
      border-radius: 10px;
      background: green;
      pointer-events: none;
      display: none;
      z-index: 999;
    }

    /* Controls layout */
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 10px;
    }
    .sliderGroup {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .sliderGroup label {
      min-width: 80px;
      text-align: right;
    }
    .sliderGroup input[type="range"] {
      width: 130px;
    }

    /* Export code output area */
    #codeOutput {
      width: 100%;
      height: 150px;
      margin-top: auto;
      font-family: monospace;
      white-space: pre;
      box-sizing: border-box;
    }

    /* Demo description text (for SEO) */
    .demo-description {
      margin-bottom: 20px;
      line-height: 1.4;
    }
  </style>
</head>
<body>

  <!-- [SEO] Page Header -->
  <header>
    <h1>Canvas Track & Fourier Demo</h1>
  </header>

  <!-- [SEO] Brief description in English -->
  <section class="demo-description">
    <p>
      This page allows you to <strong>draw a path on the canvas</strong> and then apply a <strong>Fourier transform</strong> to analyze and animate it in real-time.
    </p>
    <p>
      You can explore <em>Catmull-Rom interpolation, sampling, and DFT</em>,  
      then watch a <mark>green ball</mark> move according to the <strong>Fourier coefficients</strong> derived from your custom curve.
    </p>
  </section>

  <main id="mainWrapper">
    <!-- Left: Canvas & anchor points -->
    <div id="leftPane">
      <canvas id="myCanvas"></canvas>
      <div id="anchorsContainer"></div>
      <div id="greenCircle"></div>
    </div>

    <!-- Right: Control panel -->
    <aside id="rightPane">
      <div id="controls">
        <div class="sliderGroup">
          <label for="anchorSlider">Anchor space:</label>
          <input type="range" id="anchorSlider" min="5" max="100" value="20" />
        </div>

        <div class="sliderGroup">
          <label for="freqSlider">Max freq:</label>
          <input type="range" id="freqSlider" min="1" max="50" value="10" />
          <span id="freqValue">10</span>
        </div>

        <div class="sliderGroup">
          <label for="speedSlider">Speed:</label>
          <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1" />
          <span id="speedValue">1.0</span>
        </div>

        <button id="convertBtn">Convert</button>
        <button id="playBtn">Play</button>
        <button id="resampleBtn">Resample</button>
        <button id="exportBtn">Export</button>
        <button id="resetBtn">Reset</button>
      </div>

      <textarea id="codeOutput" readonly></textarea>
    </aside>
  </main>

  <footer>
    <p style="text-align:center; font-size:0.9em; color:#666;">
      &copy; 2023 DemoSite. All rights reserved.
    </p>
  </footer>

  <script>
    /*****************************************************************
     * Canvas & Fourier Logic (JavaScript)
     *****************************************************************/
    const canvas = document.getElementById("myCanvas");
    const ctx    = canvas.getContext("2d");

    const leftPane         = document.getElementById("leftPane");
    const anchorsContainer = document.getElementById("anchorsContainer");
    const greenCircle      = document.getElementById("greenCircle");

    const anchorSlider = document.getElementById("anchorSlider");
    const freqSlider   = document.getElementById("freqSlider");
    const freqValue    = document.getElementById("freqValue");
    const speedSlider  = document.getElementById("speedSlider");
    const speedValue   = document.getElementById("speedValue");

    const convertBtn   = document.getElementById("convertBtn");
    const playBtn      = document.getElementById("playBtn");
    const resampleBtn  = document.getElementById("resampleBtn");
    const exportBtn    = document.getElementById("exportBtn");
    const resetBtn     = document.getElementById("resetBtn");
    const codeOutput   = document.getElementById("codeOutput");

    let CANVAS_W = 0;
    let CANVAS_H = 0;
    let centerX  = 0;
    let centerY  = 0;

    let drawingMode         = true;
    let isMouseDown         = false;
    let points              = [];
    let anchorPoints        = [];
    let currentAnchorSpacing= 20;

    let fourierCoeffsX = {};
    let fourierCoeffsY = {};
    let fourierN       = 0;
    let maxFrequencyUsed = 10;

    let animationFrameId = null;
    let startTime        = null;
    let animationSpeed   = 1.0;
    let trailPoints      = [];

    function resizeCanvas() {
      canvas.width  = leftPane.clientWidth;
      canvas.height = leftPane.clientHeight;
      CANVAS_W = canvas.width;
      CANVAS_H = canvas.height;
      centerX  = CANVAS_W / 2;
      centerY  = CANVAS_H / 2;

      drawScene();
      updateAllAnchorDOMPositions();
    }

    window.addEventListener("load", () => {
      resizeCanvas();
      freqSlider.disabled = false;
    });
    window.addEventListener("resize", () => {
      resizeCanvas();
    });

    canvas.addEventListener("mousedown", (e) => {
      if (!drawingMode) return;
      isMouseDown = true;
      const { offsetX, offsetY } = e;
      points = [{ x: offsetX - centerX, y: offsetY - centerY }];
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!drawingMode || !isMouseDown) return;
      const { offsetX, offsetY } = e;
      points.push({ x: offsetX - centerX, y: offsetY - centerY });
      redrawTempLine(points);
    });

    canvas.addEventListener("mouseup", () => {
      if (!drawingMode) return;
      isMouseDown = false;

      if (points.length > 1) {
        points.push(points[0]);
        redrawTempLine(points);
      }
      drawingMode = false;
      createAnchorsFromRawPoints();
    });

    anchorSlider.addEventListener("input", (e) => {
      currentAnchorSpacing = parseInt(e.target.value);
      if (!drawingMode && points.length > 1) {
        createAnchorsFromRawPoints();
      }
    });
    freqSlider.addEventListener("input", (e) => {
      maxFrequencyUsed = parseInt(e.target.value);
      freqValue.innerText = maxFrequencyUsed;
    });
    speedSlider.addEventListener("input", (e) => {
      animationSpeed = parseFloat(e.target.value);
      speedValue.innerText = animationSpeed.toFixed(1);
    });

    convertBtn.addEventListener("click", () => {
      if (anchorPoints.length < 2) {
        alert("No path found. Draw something first!");
        return;
      }
      const uniquePoints = anchorPoints.slice(0, anchorPoints.length - 1);
      doDFT(uniquePoints);
      alert("Fourier transform completed!");
      freqSlider.disabled = true;
    });

    playBtn.addEventListener("click", () => {
      if (!fourierCoeffsX.a || fourierCoeffsX.a.length === 0) {
        alert("Please run Convert first!");
        return;
      }
      freqSlider.disabled = true;
      trailPoints = [];
      cancelAnimationFrame(animationFrameId);
      startTime = null;
      greenCircle.style.display = "block";
      animate();
    });

    resampleBtn.addEventListener("click", () => {
      if (anchorPoints.length < 2) {
        alert("Not enough anchor points to resample.");
        return;
      }
      const uniquePoints = anchorPoints.slice(0, anchorPoints.length - 1);
      createAnchorsFromAnchors(uniquePoints);
    });

    exportBtn.addEventListener("click", () => {
      if (!fourierCoeffsX.a || fourierCoeffsX.a.length === 0) {
        alert("Please run Convert first!");
        return;
      }
      codeOutput.value = generateFunctionCode();
    });

    resetBtn.addEventListener("click", () => {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;

      freqSlider.disabled = false;

      drawingMode  = true;
      isMouseDown  = false;
      points       = [];
      anchorPoints = [];
      trailPoints  = [];
      fourierCoeffsX = {};
      fourierCoeffsY = {};
      fourierN     = 0;

      anchorsContainer.innerHTML = "";
      greenCircle.style.display = "none";
      clearCanvas();
    });

    function redrawTempLine(pts) {
      ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
      drawGrid();
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) {
        ctx.lineTo(pts[i].x, pts[i].y);
      }
      ctx.strokeStyle = "black";
      ctx.stroke();
      ctx.restore();
    }

    function drawGrid() {
      const step = 50;
      ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
      ctx.save();
      ctx.translate(centerX, centerY);

      // thin grid lines
      ctx.beginPath();
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 1;
      for (let x = 0; x <= centerX; x += step) {
        ctx.moveTo(x, -centerY);
        ctx.lineTo(x, centerY);
        ctx.moveTo(-x, -centerY);
        ctx.lineTo(-x, centerY);
      }
      for (let y = 0; y <= centerY; y += step) {
        ctx.moveTo(-centerX, y);
        ctx.lineTo(centerX, y);
        ctx.moveTo(-centerX, -y);
        ctx.lineTo(centerX, -y);
      }
      ctx.stroke();

      // center axes
      ctx.beginPath();
      ctx.moveTo(-centerX, 0);
      ctx.lineTo(centerX, 0);
      ctx.moveTo(0, -centerY);
      ctx.lineTo(0, centerY);
      ctx.strokeStyle = "#888";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.restore();
    }

    function createAnchorsFromRawPoints() {
      anchorsContainer.innerHTML = "";
      clearCanvas();
      anchorPoints = sampleCatmullRom(points, currentAnchorSpacing);

      anchorPoints.forEach((p, idx) => {
        if (idx === anchorPoints.length - 1 && idx !== 0) return;
        createAnchorDOM(p.x, p.y, idx);
      });
      drawScene();
    }

    function createAnchorsFromAnchors(inputAnchors) {
      anchorsContainer.innerHTML = "";
      clearCanvas();
      anchorPoints = sampleCatmullRom(inputAnchors, currentAnchorSpacing);

      anchorPoints.forEach((p, idx) => {
        if (idx === anchorPoints.length - 1 && idx !== 0) return;
        createAnchorDOM(p.x, p.y, idx);
      });
      drawScene();
    }

    function sampleCatmullRom(pointsArr, spacing) {
      function catmullRom(t, p0, p1, p2, p3) {
        const t2 = t * t;
        const t3 = t2 * t;
        return {
          x: 0.5 * (2 * p1.x + (-p0.x + p2.x) * t
            + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2
            + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3),
          y: 0.5 * (2 * p1.y + (-p0.y + p2.y) * t
            + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2
            + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3),
        };
      }
      function segLength(a, b) {
        return Math.hypot(b.x - a.x, b.y - a.y);
      }

      let pts = [...pointsArr];
      if (pts.length > 1
       && !(pts[pts.length - 1].x === pts[0].x && pts[pts.length - 1].y === pts[0].y)) {
        pts.push(pts[0]);
      }

      let sampledPoints = [];
      const nSamples = 20;

      for (let i = 0; i < pts.length - 1; i++) {
        const p0 = pts[(i - 1 + pts.length) % pts.length];
        const p1 = pts[i];
        const p2 = pts[(i + 1) % pts.length];
        const p3 = pts[(i + 2) % pts.length];

        let segmentPoints = [];
        for (let j = 0; j < nSamples; j++) {
          const t = j / (nSamples - 1);
          const pt = catmullRom(t, p0, p1, p2, p3);
          if (j === 0 && i !== 0) continue;
          segmentPoints.push(pt);
        }
        sampledPoints = sampledPoints.concat(segmentPoints);
      }

      let newAnchors = [];
      newAnchors.push(sampledPoints[0]);
      let distAccum = 0;
      for (let i = 1; i < sampledPoints.length; i++) {
        distAccum += segLength(sampledPoints[i - 1], sampledPoints[i]);
        if (distAccum >= spacing) {
          newAnchors.push(sampledPoints[i]);
          distAccum = 0;
        }
      }
      newAnchors[newAnchors.length - 1] = newAnchors[0];
      return newAnchors;
    }

    function createAnchorDOM(cx, cy, index) {
      const anchor = document.createElement("div");
      anchor.className = "anchor";
      anchor.dataset.index = index;

      setAnchorPosition(anchor, cx, cy);

      let isDragging = false;
      let offsetScrX, offsetScrY;

      anchor.addEventListener("mousedown", (e) => {
        e.preventDefault();
        isDragging = true;
        anchor.classList.add("dragging");
        offsetScrX = e.clientX - anchor.offsetLeft;
        offsetScrY = e.clientY - anchor.offsetTop;
      });

      document.addEventListener("mousemove", (e) => {
        if (!isDragging) return;
        const newLeft = e.clientX - offsetScrX;
        const newTop  = e.clientY - offsetScrY;

        const paneRect = leftPane.getBoundingClientRect();
        const cX = (newLeft - paneRect.left) - centerX;
        const cY = (newTop  - paneRect.top ) - centerY;

        anchor.style.left = newLeft + "px";
        anchor.style.top  = newTop  + "px";

        const idx = parseInt(anchor.dataset.index);
        anchorPoints[idx] = { x: cX, y: cY };
        if (idx === 0 && anchorPoints.length > 1) {
          anchorPoints[anchorPoints.length - 1] = { x: cX, y: cY };
        }

        drawScene();
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
        anchor.classList.remove("dragging");
      });

      anchorsContainer.appendChild(anchor);
    }

    function setAnchorPosition(anchor, cx, cy) {
      const paneRect = leftPane.getBoundingClientRect();
      const screenX  = paneRect.left + centerX + cx;
      const screenY  = paneRect.top  + centerY + cy;
      anchor.style.left = screenX + "px";
      anchor.style.top  = screenY + "px";
    }

    function updateAllAnchorDOMPositions() {
      anchorPoints.forEach((p, i) => {
        const anchor = anchorsContainer.querySelector(`[data-index="${i}"]`);
        if (!anchor) return;
        setAnchorPosition(anchor, p.x, p.y);
      });
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);
    }

    function drawScene() {
      clearCanvas();
      drawGrid();
      drawSpline();
      drawTrail();
    }

    function drawSpline() {
      if (anchorPoints.length <= 1) return;
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.beginPath();
      ctx.moveTo(anchorPoints[0].x, anchorPoints[0].y);
      for (let i = 1; i < anchorPoints.length; i++) {
        ctx.lineTo(anchorPoints[i].x, anchorPoints[i].y);
      }
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    function drawTrail() {
      if (trailPoints.length < 2) return;
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.beginPath();
      ctx.moveTo(trailPoints[0].x, trailPoints[0].y);
      for (let i = 1; i < trailPoints.length; i++) {
        ctx.lineTo(trailPoints[i].x, trailPoints[i].y);
      }
      ctx.strokeStyle = "green";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }

    function doDFT(pts) {
      const N = pts.length;
      const xArr = pts.map(p => p.x);
      const yArr = pts.map(p => p.y);

      let aX = new Array(N).fill(0);
      let bX = new Array(N).fill(0);
      let aY = new Array(N).fill(0);
      let bY = new Array(N).fill(0);

      for (let n = 0; n < N; n++) {
        let sumCosX = 0, sumSinX = 0;
        let sumCosY = 0, sumSinY = 0;
        for (let k = 0; k < N; k++) {
          const angle = (2 * Math.PI * n * k) / N;
          sumCosX += xArr[k] * Math.cos(angle);
          sumSinX += xArr[k] * Math.sin(angle);
          sumCosY += yArr[k] * Math.cos(angle);
          sumSinY += yArr[k] * Math.sin(angle);
        }
        aX[n] = (2 / N) * sumCosX;
        bX[n] = (2 / N) * sumSinX;
        aY[n] = (2 / N) * sumCosY;
        bY[n] = (2 / N) * sumSinY;
      }

      fourierCoeffsX = { a: aX, b: bX };
      fourierCoeffsY = { a: aY, b: bY };
      fourierN = N;
    }

    function animate(timestamp) {
      if (!startTime) startTime = timestamp;
      const elapsed = (timestamp - startTime) / 1000;
      const t = (animationSpeed * elapsed) % (2 * Math.PI);

      const { x, y } = getXY(t);
      trailPoints.push({ x, y });

      drawScene();

      const paneRect = leftPane.getBoundingClientRect();
      const screenX  = paneRect.left + centerX + x;
      const screenY  = paneRect.top  + centerY + y;
      // Adjust to make the circle's center match (x, y)
      greenCircle.style.left = (screenX - 5) + "px";
      greenCircle.style.top  = (screenY - 5) + "px";

      animationFrameId = requestAnimationFrame(animate);
    }

    function getXY(t) {
      let x = 0, y = 0;
      const limit = Math.min(maxFrequencyUsed, fourierN - 1);
      for (let n = 0; n <= limit; n++) {
        x += fourierCoeffsX.a[n] * Math.cos(n * t)
           + fourierCoeffsX.b[n] * Math.sin(n * t);
        y += fourierCoeffsY.a[n] * Math.cos(n * t)
           + fourierCoeffsY.b[n] * Math.sin(n * t);
      }
      return { x, y };
    }

    function generateFunctionCode() {
      const aX = fourierCoeffsX.a;
      const bX = fourierCoeffsX.b;
      const aY = fourierCoeffsY.a;
      const bY = fourierCoeffsY.b;
      const N  = fourierN;
      const limit = Math.min(maxFrequencyUsed, N - 1);

      let xFunc = "function x(t) {\n  let result = 0;\n";
      for (let n = 0; n <= limit; n++) {
        xFunc += `  result += ${aX[n].toFixed(5)} * Math.cos(${n} * t)`
               + ` + ${bX[n].toFixed(5)} * Math.sin(${n} * t);\n`;
      }
      xFunc += "  return result;\n}";

      let yFunc = "function y(t) {\n  let result = 0;\n";
      for (let n = 0; n <= limit; n++) {
        yFunc += `  result += ${aY[n].toFixed(5)} * Math.cos(${n} * t)`
               + ` + ${bY[n].toFixed(5)} * Math.sin(${n} * t);\n`;
      }
      yFunc += "  return result;\n}";

      return xFunc + "\n\n" + yFunc;
    }
  </script>
</body>
</html>
